from __future__ import annotations
from typing import List, Tuple, Dict, Set, Callable, Any
import time
import logging

from rna_pk_fold.structures import Pair
from rna_pk_fold.folding.common_traceback import pairs_to_multilayer_dotbracket, TraceResult
from rna_pk_fold.folding.eddy_rivas.eddy_rivas_fold_state import EddyRivasFoldState
from rna_pk_fold.folding.eddy_rivas.eddy_rivas_recurrences import EddyRivasBacktrackOp
from rna_pk_fold.utils.traceback_ops_utils import merge_nested_interval, place_pair_non_crossing, audit_layer_map
from rna_pk_fold.utils.back_pointer_utils import wx_bp, whx_bp, yhx_bp, zhx_bp, vhx_bp

logger = logging.getLogger(__name__)


def traceback_with_pk(
    seq: str,
    *,
    nested_state: Any,
    eddy_rivas_fold_state: EddyRivasFoldState,
    trace_nested_interval: Callable[[str, Any, int, int], TraceResult],
) -> TraceResult:
    """
    Reconstructs the optimal RNA secondary structure, including pseudoknots.

    This function implements a stack-based state machine to navigate the
    backpointers generated by the Rivas-Eddy dynamic programming algorithm.
    It starts from the top-level structure `WX(0, N-1)` and recursively
    decomposes it into smaller subproblems (frames) until the entire
    structure is resolved into a set of base pairs.

    Nested substructures are delegated to an external traceback function,
    allowing this implementation to focus solely on resolving the pseudoknotted
    grammar.

    Parameters
    ----------
    seq : str
        The RNA sequence that was folded.
    nested_state : Any
        The state object from the nested-only folding engine (e.g.,
        ZuckerFoldState). This is treated as an opaque object and is passed
        directly to the `trace_nested_interval` function.
    eddy_rivas_fold_state : EddyRivasFoldState
        The state object containing the filled dynamic programming matrices
        and backpointers from the Rivas-Eddy algorithm.
    trace_nested_interval : Callable[[str, Any, int, int], TraceResult]
        A function responsible for tracing a purely nested secondary
        structure within a given interval `[i, j]`.

    Returns
    -------
    TraceResult
        A data object containing the final list of base pairs and the
        corresponding multilayer dot-bracket string representation.
    """
    start_time = time.perf_counter()

    seq_len = eddy_rivas_fold_state.seq_len
    if seq_len == 0:
        return TraceResult(pairs=[], dot_bracket="")

    logger.info(f"Starting traceback for sequence length N={seq_len}")

    # --- State Initialization ---
    # The `stack` holds "frames" representing subproblems to be solved.
    # Each frame is a tuple: (TAG, *coordinates, layer).
    # The TAG (e.g., "WX", "WHX") indicates the type of DP matrix to query.
    # The 'layer' is used to assign non-crossing helices in the final dot-bracket.
    frame = Tuple

    # Start with the entire sequence as a WX problem on layer 0.
    stack: List[frame] = [("WX", 0, seq_len - 1, 0)]

    # `pairs` will store the final set of (i, j) base pairs.
    pairs: Set[Pair] = set()

    # `pair_layer` maps each pair to its assigned dot-bracket layer.
    pair_layer: Dict[Tuple[int, int], int] = {}

    # --- Debugging Block ---
    # This block probes the initial backpointer for the full sequence to provide
    # immediate insight into the top-level structure (nested vs. pseudoknotted).
    bp0 = wx_bp(eddy_rivas_fold_state, 0, seq_len - 1)
    if bp0:
        print(
            f"[WX WIN] op={bp0.op} split={bp0.split} "
            f"hole={bp0.hole} hole_left={bp0.hole_left} hole_right={bp0.hole_right}",
            flush=True
        )
    else:
        print("[WX WIN] None → nested only", flush=True)

    # If the top-level structure is a composition, probe the subproblem backpointers.
    if bp0 and bp0.op in (
            EddyRivasBacktrackOp.RE_PK_COMPOSE_WX_YHX_WHX,
            EddyRivasBacktrackOp.RE_PK_COMPOSE_WX_WHX_YHX,
            EddyRivasBacktrackOp.RE_PK_COMPOSE_WX_YHX,
            EddyRivasBacktrackOp.RE_PK_COMPOSE_WX,
    ):
        # Determine the exact coordinates of the left and right sub-holes.
        r = bp0.split
        if bp0.hole_left:
            k_l, l_l = bp0.hole_left
        else:
            k_l, l_l = (bp0.hole[0], r) if bp0.hole else (None, None)

        if bp0.hole_right:
            k_r, l_r = bp0.hole_right
        else:
            _, l = bp0.hole if bp0.hole else (None, None)
            k_r, l_r = (r + 1, l)

        # Check if backpointers exist for the specific subproblems that will be traced.
        ybp = yhx_bp(eddy_rivas_fold_state, 0, r, k_l, l_l)
        wbp = whx_bp(eddy_rivas_fold_state, r + 1, seq_len - 1, k_r, l_r)

        print(f"[PROBE] YHX[0,{r}:{k_l},{l_l}] BP?",
              "yes" if ybp else "no",
              f"op={getattr(ybp, 'op', None)}", flush=True)
        print(f"[PROBE] WHX[{r + 1},{seq_len - 1}:{k_r},{l_r}] BP?",
              "yes" if wbp else "no",
              f"op={getattr(wbp, 'op', None)}", flush=True)

    # --- Main Traceback Loop ---
    # Process frames from the stack until all subproblems are resolved.
    while stack:
        # Pop the next subproblem to work on.
        frame = stack.pop()
        print(f"[TB POP] {frame}", flush=True)
        tag = frame[0]

        # --- 1. WX Frame Processing ---
        # WX represents the most general problem for an interval [i, j].
        if tag == "WX":
            _, i, j, layer = frame
            bp = wx_bp(eddy_rivas_fold_state, i, j)

            # 1.1. If no backpointer, or if the backpointer explicitly selects the 'uncharged' (nested) path...
            if not bp or bp.op is EddyRivasBacktrackOp.RE_WX_SELECT_UNCHARGED:
                # ...delegate this entire interval to the nested traceback function.
                merge_nested_interval(seq, nested_state, i, j, layer,
                                      trace_nested_interval, pairs, pair_layer)
                continue

            op = bp.op
            r = bp.split
            k, l = (bp.hole if bp.hole is not None else (None, None))

            # 1.2. Handle WX composition from two WHX subproblems.
            if op is EddyRivasBacktrackOp.RE_PK_COMPOSE_WX:
                if bp.hole_left and bp.hole_right:
                    k_l, l_l = bp.hole_left
                    k_r, l_r = bp.hole_right
                else:
                    k_l, l_l = k, l
                    k_r, l_r = (r + 1, r + 1)

                # Both subproblems are WHX and are considered part of the base nested layer.
                stack.append(("WHX", i, r, k_l, l_l, 0))
                stack.append(("WHX", r, j, k_r, l_r, 0))
                continue

            # 1.3. Handle WX composition from two YHX subproblems.
            if op is EddyRivasBacktrackOp.RE_PK_COMPOSE_WX_YHX:
                # Left: uses (i, r, k, l)
                # Right: uses YHX(k+1, j, l-1, r+1) → test expects inner pair (3,3) in the example
                stack.append(("YHX", i, r, k, l, layer + 1))
                stack.append(("YHX", k + 1, j, l - 1, r + 1, layer + 2))
                continue

            # 1.4. Handle WX composition from two overlapping YHX subproblems.
            if op is EddyRivasBacktrackOp.RE_PK_COMPOSE_WX_YHX_OVERLAP:
                # Both branches share the same (k,l); no BPs are needed—YHX will place (k,l) on entry
                stack.append(("YHX", i, r, k, l, layer + 1))
                stack.append(("YHX", r + 1, j, k, l, layer + 2))
                continue

            # 1.5. Handle WX composition from a YHX (crossing) and a WHX (nested) subproblem.
            if op is EddyRivasBacktrackOp.RE_PK_COMPOSE_WX_YHX_WHX:
                stack.append(("YHX", i, r, k, l, layer + 1))
                stack.append(("WHX", r + 1, j, r + 1, l - 1, 0))
                continue

            # 1.6. Handle WX composition from a WHX (nested) and a YHX (crossing) subproblem.
            if op is EddyRivasBacktrackOp.RE_PK_COMPOSE_WX_WHX_YHX:
                stack.append(("WHX", i, r, k, l, 0))
                stack.append(("YHX", k + 1, j, l - 1, r + 1, layer + 1))
                continue

            # 1.6. Fallback for any other WX operation: treat as a simple nested interval.
            merge_nested_interval(seq, nested_state, i, j, layer,
                                  trace_nested_interval, pairs, pair_layer)
            continue

        # --- 2. WHX Frame Processing ---
        # WHX is a gapped structure with undetermined pairing at all ends.
        if tag == "WHX":
            _, i, j, k, l, layer = frame
            logger.debug(f"\n=== WHX[{i},{j},{k},{l}] layer={layer} ===")
            bp = whx_bp(eddy_rivas_fold_state, i, j, k, l)

            # 2.1. If no backpointer, it implies the hole collapsed. Treat the outer span as nested.
            if not bp:
                print(f"[WHX MISS] merging nested [{i},{j}] hole=({k},{l}) layer={layer}", flush=True)
                merge_nested_interval(seq, nested_state, i, j, layer,
                                      trace_nested_interval, pairs, pair_layer)
                continue

            print(f"[WHX] ({i},{j}:{k},{l}) layer={layer} op={bp.op}", flush=True)
            op = bp.op

            # 2.2. Add an unpaired base at the 5' end of the hole. Push the smaller subproblem.
            if op is EddyRivasBacktrackOp.RE_WHX_SHRINK_LEFT:
                stack.append(("WHX", i, j, k + 1, l, layer))

            # 2.3. Add an unpaired base at the 3' end of the hole.
            elif op is EddyRivasBacktrackOp.RE_WHX_SHRINK_RIGHT:
                stack.append(("WHX", i, j, k, l - 1, layer))

            # 2.4. Add an unpaired base at the 5' end of the outer span.
            elif op is EddyRivasBacktrackOp.RE_WHX_TRIM_LEFT:
                stack.append(("WHX", i + 1, j, k, l, layer))

            # 2.5. Add an unpaired base at the 3' end of the outer span.
            elif op is EddyRivasBacktrackOp.RE_WHX_TRIM_RIGHT:
                stack.append(("WHX", i, j - 1, k, l, layer))

            # 2.6. Add unpaired bases at both outer ends.
            elif op is EddyRivasBacktrackOp.RE_WHX_SS_BOTH:
                stack.append(("WHX", i + 1, j - 1, k, l, layer))

            # 2.7. The hole has collapsed into a purely nested structure.
            elif op is EddyRivasBacktrackOp.RE_WHX_COLLAPSE:
                if bp.outer:
                    oi, oj = bp.outer
                    merge_nested_interval(seq, nested_state, oi, oj, layer,
                                          trace_nested_interval, pairs, pair_layer)
                else:
                    merge_nested_interval(seq, nested_state, i, j, layer,
                                          trace_nested_interval, pairs, pair_layer)

            # 2.8. Bifurcation into a smaller WHX and a nested WX.
            elif op is EddyRivasBacktrackOp.RE_WHX_SPLIT_LEFT_WHX_WX:
                r = bp.split if bp.split is not None else (i + j) // 2
                stack.append(("WHX", i, r, k, l, layer))
                merge_nested_interval(seq, nested_state, r + 1, j, layer,
                                      trace_nested_interval, pairs, pair_layer)

            # 2.9. Bifurcation into a nested WX and a smaller WHX.
            elif op is EddyRivasBacktrackOp.RE_WHX_SPLIT_RIGHT_WX_WHX:
                s2 = bp.split if bp.split is not None else (i + j) // 2
                merge_nested_interval(seq, nested_state, i, s2, layer,
                                      trace_nested_interval, pairs, pair_layer)
                stack.append(("WHX", s2 + 1, j, k, l, layer))

            # 2.10. Overlapping pseudoknot from two smaller WHX subproblems.
            elif op is EddyRivasBacktrackOp.RE_WHX_OVERLAP_SPLIT:
                r = bp.split if bp.split is not None else (i + j) // 2
                stack.append(("WHX", i, r, k, l, layer))
                stack.append(("WHX", r + 1, j, k, l, layer))

            else:
                # Fallback for unknown operations.
                logger.warning(f"Unknown WHX op: {op}, falling back to nested")
                merge_nested_interval(seq, nested_state, i, j, layer,
                                      trace_nested_interval, pairs, pair_layer)

            continue

        # --- 3. YHX Frame Processing ---
        # YHX has a paired inner hole (k,l) but an undetermined outer span (i,j).
        if tag == "YHX":
            _, i, j, k, l, layer = frame
            place_pair_non_crossing(pairs, pair_layer, k, l, layer)
            logger.debug(f"YHX[{i},{j},{k},{l}] layer={layer}")

            bp = yhx_bp(eddy_rivas_fold_state, i, j, k, l)
            if not bp:
                print(f"[YHX MISS] ({i},{j}:{k},{l}) layer={layer} → no BP", flush=True)
                continue
            print(f"[YHX] ({i},{j}:{k},{l}) layer={layer} op={bp.op}", flush=True)
            op = bp.op

            # 3.1. For adding dangles or unpaired bases, push the corresponding smaller subproblem.
            if op is EddyRivasBacktrackOp.RE_YHX_DANGLE_L:
                stack.append(("VHX", i + 1, j, k, l, layer))
            elif op is EddyRivasBacktrackOp.RE_YHX_DANGLE_R:
                stack.append(("VHX", i, j - 1, k, l, layer))
            elif op is EddyRivasBacktrackOp.RE_YHX_DANGLE_LR:
                stack.append(("VHX", i + 1, j - 1, k, l, layer))
            # SS trims → push YHX with modified coordinates
            elif op is EddyRivasBacktrackOp.RE_YHX_SS_LEFT:
                stack.append(("YHX", i + 1, j, k, l, layer))
            elif op is EddyRivasBacktrackOp.RE_YHX_SS_RIGHT:
                stack.append(("YHX", i, j - 1, k, l, layer))
            elif op is EddyRivasBacktrackOp.RE_YHX_SS_BOTH:
                stack.append(("YHX", i + 1, j - 1, k, l, layer))

            # 3.2. For wrapping a multiloop around a WHX. This forms the (k,l) pair.
            elif op is EddyRivasBacktrackOp.RE_YHX_WRAP_WHX:
                wi, wj = bp.outer if bp.outer else (i, j)
                wk, wl = bp.hole if bp.hole else (k - 1, l + 1)
                stack.append(("WHX", wi, wj, wk, wl, 0))
            elif op is EddyRivasBacktrackOp.RE_YHX_WRAP_WHX_L:
                wi, wj = bp.outer if bp.outer else (i + 1, j)
                wk, wl = bp.hole if bp.hole else (k - 1, l + 1)
                stack.append(("WHX", wi, wj, wk, wl, 0))
            elif op is EddyRivasBacktrackOp.RE_YHX_WRAP_WHX_R:
                wi, wj = bp.outer if bp.outer else (i, j - 1)
                wk, wl = bp.hole if bp.hole else (k - 1, l + 1)
                stack.append(("WHX", wi, wj, wk, wl, 0))
            elif op is EddyRivasBacktrackOp.RE_YHX_WRAP_WHX_LR:
                wi, wj = bp.outer if bp.outer else (i + 1, j - 1)
                wk, wl = bp.hole if bp.hole else (k - 1, l + 1)
                stack.append(("WHX", wi, wj, wk, wl, 0))

            # 3.3. Bifurcation.
            elif op is EddyRivasBacktrackOp.RE_YHX_SPLIT_LEFT_YHX_WX:
                r = bp.split if bp.split is not None else (i + j) // 2
                stack.append(("YHX", i, r, k, l, layer))
                merge_nested_interval(seq, nested_state, r + 1, j, 0,
                                      trace_nested_interval, pairs, pair_layer)
            elif op is EddyRivasBacktrackOp.RE_YHX_SPLIT_RIGHT_WX_YHX:
                s2 = bp.split if bp.split is not None else (i + j) // 2
                merge_nested_interval(seq, nested_state, i, s2, 0,
                                      trace_nested_interval, pairs, pair_layer)
                stack.append(("YHX", s2 + 1, j, k, l, layer))

            # 3.4. For IS2 motif, delegate to WHX
            elif op is EddyRivasBacktrackOp.RE_YHX_IS2_INNER_WHX:
                (r, s2) = bp.bridge if bp.bridge else (i, j)
                stack.append(("WHX", r, s2, k, l, layer))

            # 3.6. Unknown operation fallback
            else:
                logger.warning(f"Unknown YHX op: {op}, skipping")

            continue

        # --- 4. ZHX Frame Processing ---
        # ZHX has a paired outer span (i,j) but an undetermined inner hole (k,l).
        if tag == "ZHX":
            _, i, j, k, l, layer = frame

            bp = zhx_bp(eddy_rivas_fold_state, i, j, k, l)
            if not bp:
                continue
            op = bp.op

            # 4.1. For forming the inner pair (k,l), transition to a VHX subproblem.
            if op is EddyRivasBacktrackOp.RE_ZHX_FROM_VHX:
                stack.append(("VHX", i, j, k, l, layer))
            elif op is EddyRivasBacktrackOp.RE_ZHX_DANGLE_L:
                stack.append(("VHX", i, j, k, l + 1, layer))
            elif op is EddyRivasBacktrackOp.RE_ZHX_DANGLE_R:
                stack.append(("VHX", i, j, k - 1, l, layer))
            elif op is EddyRivasBacktrackOp.RE_ZHX_DANGLE_LR:
                stack.append(("VHX", i, j, k - 1, l + 1, layer))

            # 4.2. For adding unpaired bases, recurse on a smaller ZHX.
            elif op is EddyRivasBacktrackOp.RE_ZHX_SS_LEFT:
                stack.append(("ZHX", i, j, k - 1, l, layer))
            elif op is EddyRivasBacktrackOp.RE_ZHX_SS_RIGHT:
                stack.append(("ZHX", i, j, k, l + 1, layer))

            # 4.3. Bifurcations
            elif op is EddyRivasBacktrackOp.RE_ZHX_SPLIT_LEFT_ZHX_WX:
                r = bp.split if bp.split is not None else (i + k) // 2
                stack.append(("ZHX", i, j, r, l, layer))
                merge_nested_interval(seq, nested_state, r + 1, k, 0,
                                      trace_nested_interval, pairs, pair_layer)
            elif op is EddyRivasBacktrackOp.RE_ZHX_SPLIT_RIGHT_ZHX_WX:
                s2 = bp.split if bp.split is not None else (l + j) // 2
                stack.append(("ZHX", i, j, k, s2, layer))
                merge_nested_interval(seq, nested_state, l, s2 - 1, 0,
                                      trace_nested_interval, pairs, pair_layer)

            # 4.4. An IS2 motif,
            elif op is EddyRivasBacktrackOp.RE_ZHX_IS2_INNER_VHX:
                (r, s2) = bp.bridge if bp.bridge else (k, l)
                stack.append(("VHX", r, s2, k, l, layer))

            # 4.5. Unknown operation fallback
            else:
                logger.warning(f"Unknown ZHX op: {op}, skipping")

            continue

        # --- 5. VHX Frame Processing ---
        # VHX is the most constrained gapped structure: both (i,j) and (k,l) are paired.
        if tag == "VHX":
            _, i, j, k, l, layer = frame

            bp = vhx_bp(eddy_rivas_fold_state, i, j, k, l)
            if not bp:
                print(f"[VHX MISS] ({i},{j}:{k},{l}) layer={layer} → no BP", flush=True)
                continue
            print(f"[VHX] ({i},{j}:{k},{l}) layer={layer} op={bp.op}", flush=True)
            op = bp.op

            # 5.1. Dangles on the inner pair (k,l).
            if op is EddyRivasBacktrackOp.RE_VHX_DANGLE_L:
                stack.append(("VHX", i, j, k + 1, l, layer))
            elif op is EddyRivasBacktrackOp.RE_VHX_DANGLE_R:
                stack.append(("VHX", i, j, k, l - 1, layer))
            elif op is EddyRivasBacktrackOp.RE_VHX_DANGLE_LR:
                stack.append(("VHX", i, j, k + 1, l - 1, layer))

            # 5.2. For adding unpaired bases, transition to a ZHX subproblem.
            elif op is EddyRivasBacktrackOp.RE_VHX_SS_LEFT:
                stack.append(("ZHX", i, j, k - 1, l, layer))
            elif op is EddyRivasBacktrackOp.RE_VHX_SS_RIGHT:
                stack.append(("ZHX", i, j, k, l + 1, layer))

            # 5.3. Bifurcation.
            elif op is EddyRivasBacktrackOp.RE_VHX_SPLIT_LEFT_ZHX_WX:
                r = bp.split if bp.split is not None else (i + k) // 2
                stack.append(("ZHX", i, j, r, l, layer))
                merge_nested_interval(seq, nested_state, r + 1, k, 0, trace_nested_interval, pairs, pair_layer)
            elif op is EddyRivasBacktrackOp.RE_VHX_SPLIT_RIGHT_ZHX_WX:
                s2 = bp.split if bp.split is not None else (l + j) // 2
                stack.append(("ZHX", i, j, k, s2, layer))
                merge_nested_interval(seq, nested_state, i, s2, 0, trace_nested_interval, pairs, pair_layer)

            # 5.4. An IS2 motif.
            elif op is EddyRivasBacktrackOp.RE_VHX_IS2_INNER_ZHX:
                (r, s2) = bp.bridge if bp.bridge else (i, j)
                stack.append(("ZHX", r, s2, k, l, layer))

            # 5.5. Mulitloop wrap
            elif op is EddyRivasBacktrackOp.RE_VHX_WRAP_WHX:
                (wi, wj) = bp.outer if bp.outer else (i, j)
                stack.append(("WHX", wi, wj, k, l, 0))

            # 5.6. Where BOTH pairs (i,j) and (k,l) are formed simultaneously.
            elif op is EddyRivasBacktrackOp.RE_VHX_CLOSE_BOTH:
                # Place both helices, assigning them to non-conflicting layers.
                layer_outer = place_pair_non_crossing(pairs, pair_layer, i, j, layer)  # outer helix
                layer_inner = place_pair_non_crossing(pairs, pair_layer, k, l, layer)  # inner helix

                # Optional debug to see where they landed
                if layer_outer != layer or layer_inner != layer:
                    print(f"[BUMP] VHX_CLOSE_BOTH: outer({i},{j})→L{layer_outer}, inner({k},{l})→L{layer_inner}",
                          flush=True)

                # The content inside the multiloop is a nested WHX structure.
                if bp.outer and bp.hole:
                    wi, wj = bp.outer
                    wk, wl = bp.hole
                    stack.append(("WHX", wi, wj, wk, wl, 0))

            continue

    # --- Finalization ---
    # Sort the collected pairs by their 5' index.
    ordered = sorted(pairs, key=lambda pr: (pr.base_i, pr.base_j))

    # Convert the pairs and their layer assignments into a multilayer dot-bracket string.
    dot = pairs_to_multilayer_dotbracket(seq_len, ordered, pair_layer)

    # Perform a final sanity check on the layer assignments.
    audit_layer_map(pair_layer)

    # Log the final results and performance and return final structure.
    elapsed = time.perf_counter() - start_time
    logger.info(f"Traceback completed in {elapsed:.3f}s")
    logger.info(f"Found {len(ordered)} base pairs")

    return TraceResult(pairs=ordered, dot_bracket=dot)
